@코틀린 학습 병행(메모장 참고)

@디버그는 브레이크포인트(디버그시점, 보통 메인메소드 끝) 걸고
브레이크 포인트 여러개 후 디버깅에서 순서대로 볼 수 있음

@디버그 스텝인투(메소드에 브레이크 걸어도 비슷한 효과)

#자료형과 연산
- 삼항 연산자 실습
- 이스케이프 실습
- 스트링 상수 풀과 스트링빌더 추가 학습
- final은 상수라기 보단 일회성 변수로 보는게 나음, 상수 대문자

#정수
- 바이트 쇼트 연산시 인트로 취급
- 초기화 이후의 오버플로우는 컴파일러가 관여x > 런타임에러
- 리터럴은 ++ 사용 불가
- 자료형이 달라도 값이 같다면 동일

#실수
- 1 + 8(exponent) + 23(첫 1포함 앞 전부 제거)
- decimal 라이브러리

#문자
- 문자와 문자열은 연산 방식 다름
- 리터럴과 정수 연산의 형변환 차이
- 공백은 문자 x 문자열 o(str자체가 공백에서 시작)

#불리안
- 애초에 정보 취급시 단위가 비트가 아닌 바이트
- pri && > ||
- 단축평가시 후위의 부수 효과가 적용되지 않음

#문자열
* 리터럴 생성시에만 스트링 상수 풀을 이용하여 중복값 동일 참조 > 따라서 최대한 string은 리터럴 사용
- 인스턴스 생성시 기존 참조처럼 작동
- + 복합대입연산(+=)은 가능
- Boolean.parseBoolean은 "true" 제외 모두 false

#문자열 메소드
- \t \n 등도 일부 메소드 공백 취급
- concat : 문자열만, 필요시만 새 인스턴스(+는 늘 생성), null 체크(+는 무시), 그러나 성능은 +가 좋음(다중 연산시 매번 값 생성)
- replaceAll/First의 regrex는 정규표현식

#포매팅
- 13버전부터는 변수에 .formatted 가능/이전까지는 String 메서드
- printf
- 리눅스는 \n 윈도우는 \r\n : 옛 타자기시절 개행시 왼쪽으로 넘기는 전통
> 따라서 %n으로 OS별 줄바꿈 통일
- 기본적으로 %f는 6자리까지

#null
- 초기화되지 않은 객체 > 컴파일, null > 런타임

#array
- 초기화시 숫자는 0 bool은 false char은 아스키코드 0 string은 null

#타입추론
- var 선언시 반드시 초기화 필요/local var만 가능

#if
- 인텔리제이 단축어 foreach

#switch
- break 없으면 case 틀려도 내부 출력

#for
- 최대한 변수를 줄일수록 안전한 for loop(lambda도 마찬가지)

#메소드
- 함수와의 차이는 클래스 의존성 > 역사는 과거 언어인 simula
- 메소드 선언시 param, 메소드 사용시 argum
- ...(varargs)는 기본적으로 primitive를 배열로 묶지만 배열이 들어와도 작동
- varargs는 가장 마지막 param으로 사용, 중복 사용 불가

#재귀
- 재귀함수 자체도 별로지만 자바에선 보안 등의 이슈로 꼬리 재귀 최적화가 불가

#클래스
- public이 아니면 파일명 클래스명 일치할 필요 X(컴파일 후 .class 파일을 인터프리팅할 때 공용 클래스 식별)
* 클래스 로더가 클래스를 찾을 때 특정한 규칙을 따르는데, 이 때 메인 메소드가 그 시작점이 되므로 static을 쓰듯이 Class.main처럼 jvm이
사용하기 쉽도록 관례상 적용
- this 생성될 인스턴스, #1 매개변수 구분을 위해서도 사용(클래스, 인스턴스 멤버)
- 생성자는 컴파일러가 자동 생성



#static
- 인스턴스에서도 클래스 변수를 사용할 수는 있음.(비권장, IDE 자동완성 x)

#접근제어
- modifier로 제한자 병기도 자주 사용

#상속
- private같은 접근제어도 상속은 되지만 외부 사용은 불가
- 자식의 생성자는 무조건 super 시작(즉, 부모 인스턴스 반드시 생성)
- 부모 생성자 선언 x > 자식도 x 가능 (부모 선언시 자식도 반드시 선언)

#인터페이스
- 하위호환성을 위한 default 메소드 추가로 유연성을 확보하고 라이브러리 추가가 더 유연해짐(호환을 유지하며
새로운 기능 추가)

#패키지
- out 빌드 파일 직접 실행해보기

#레코드
- 16부터 도입, class와 enum의 중간
- inner class처럼 클래스 내부 사용 가능