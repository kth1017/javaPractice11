@클래스와 변수명에 관례 문자열 쓰지 말 것

@자바는 클래스 내부에서 변수 초기화나 메소드 호출이 메소드나 초기화 블록 안에서 이루어져야 함
> 명백한 실행 순서(*), 예외 처리, 유지보수성, 객체지향 면에서 생긴 규칙임을 기억
* 클래스 내부 로직에 메소드 호출을 만약 허용할 경우 인스턴스 변수 초기화시 문제 발생

@디버그는 브레이크포인트(디버그시점, 보통 메인메소드 끝) 걸고
브레이크 포인트 여러개 후 디버깅에서 순서대로 볼 수 있음

@디버그 스텝인투(메소드에 브레이크 걸어도 비슷한 효과)

# 자료형과 연산
- 삼항 연산자 실습
- 이스케이프 실습
- 스트링 상수 풀과 스트링빌더 추가 학습
- final은 상수라기 보단 일회성 변수로 보는게 나음, 상수 대문자

# 정수
- 바이트 쇼트 연산시 인트로 취급
- 초기화 이후의 오버플로우는 컴파일러가 관여x > 런타임에러
- 리터럴은 ++ 사용 불가
- 자료형이 달라도 값이 같다면 동일

# 실수
- 1 + 8(exponent) + 23(첫 1포함 앞 전부 제거)
- decimal 라이브러리

# 문자
- 문자와 문자열은 연산 방식 다름(예제 참고)
- 리터럴과 정수 연산의 형변환 차이
- 공백은 문자 x 문자열 o(str자체가 공백에서 시작)

# 불리안
- 애초에 정보 취급시 단위가 비트가 아닌 바이트
- pri && > ||
- 단축평가시 후위의 부수 효과가 적용되지 않음

# 문자열
* 리터럴 생성시에만 스트링 상수 풀을 이용하여 중복값 동일 참조 > 따라서 최대한 string은 리터럴 사용
- 인스턴스 생성시 기존 참조처럼 작동
- + 복합대입연산(+=)은 가능
- Boolean.parseBoolean은 "true" 제외 모두 false

# 문자열 메소드
- \t \n 등도 일부 메소드 공백 취급
- concat : 문자열만, 필요시만 새 인스턴스(+는 늘 생성), null 체크(+는 무시), 그러나 성능은 +가 좋음(다중 연산시 매번 값 생성)
- replaceAll/First의 regrex는 정규표현식

# 포매팅
- 13버전부터는 변수에 .formatted 가능/이전까지는 String 메서드
- printf
- 리눅스는 \n 윈도우는 \r\n : 옛 타자기시절 개행시 왼쪽으로 넘기는 전통
> 따라서 %n으로 OS별 줄바꿈 통일
- 기본적으로 %f는 6자리까지

# null
- 초기화되지 않은 객체 > 컴파일, null > 런타임

# array
- 초기화시 숫자는 0 bool은 false char은 아스키코드 0 string은 null

# 타입추론
- var 선언시 반드시 초기화 필요/local var만 가능

# if
- 인텔리제이 단축어 foreach

# switch
- break 없으면 case 틀려도 내부 출력

# for
- 최대한 변수를 줄일수록 안전한 for loop(lambda도 마찬가지)

# 메소드
- 함수와의 차이는 클래스 의존성 > 역사는 과거 언어인 simula
- 메소드 선언시 param, 메소드 사용시 argum
- ...(varargs)는 기본적으로 primitive를 배열로 묶지만 배열이 들어와도 작동
- varargs는 가장 마지막 param으로 사용, 중복 사용 불가

# 재귀
- 재귀함수 자체도 별로지만 자바에선 보안 등의 이슈로 꼬리 재귀 최적화가 불가
- 꼬리 재귀 사용 선택 고려

# 클래스
- C의 구조체와 거의 유사하며 C++의 경우 구조체와 클래스간 상속도 제한적으로 가능
- public이 아니면 파일명 클래스명 일치할 필요 X(컴파일 후 .class 파일을 인터프리팅할 때 공용 클래스 식별)
* 클래스 로더가 클래스를 찾을 때 특정한 규칙을 따르는데, 이 때 메인 메소드가 그 시작점이 되므로 static을 쓰듯이 Class.main처럼 jvm이
사용하기 쉽도록 관례상 적용
- this 생성될 인스턴스, #1 매개변수 구분을 위해서도 사용(클래스, 인스턴스 멤버)
- 생성자는 컴파일러가 자동 생성

# 인스턴스
- 객체와 인스턴스는 자바에선 거의 동등하게 사용되지만 개념적이거나 다른 언어에선 객체가 더 포괄적이고 인스턴스가 더 구체적인 표현
- 클래스의 인스턴스화는 다음 순서를 가짐
1 메모리 할당 2 인스턴스 변수 초기화(int라면 0으로) 3 생성자 호출


# static
- 인스턴스에서도 클래스 변수를 사용할 수는 있음.(비권장, IDE 자동완성 x)

# 접근제어
- modifier로 제한자 병기도 자주 사용

# 상속
- private같은 접근제어도 상속은 되지만 외부 사용은 불가
- 자식의 생성자는 무조건 super 시작(즉, 부모 인스턴스 반드시 생성)
- 부모 생성자 선언 x > 자식도 x 가능 (부모 선언시 자식도 반드시 선언)

# 인터페이스
- 하위호환성을 위한 default 메소드 추가로 유연성을 확보하고 라이브러리 추가가 더 유연해짐(호환을 유지하며
새로운 기능 추가)

# 패키지
- out 빌드 파일 직접 실행해보기

# 메인메소드
- args : 인수보다 큰 의미는 없음

# enum
- 코드 가독성 및 실수 방지를 위해 도입(이전엔 final > interface 상수 > 객체 상수를 겪음)
- 필드, 메소드, 생성자 사용 가능
- reference type이기에 힙에 따로 저장
- 메모리를 따로 먹기에 고려되는 성능 문제의 경우도 미미함

# 레코드
- 16부터 도입, class와 enum의 중간(근본적으론 class)
- js의 jason이나 c의 구조체와 유사
- 인터페이스 필드처럼 기본적으로 final + private며 생성자, getter가 기본 생성
- inner class처럼 클래스 내부 사용 가능
- class 필드는 가질 수 있음, 인터페이스 구현 가능

# time
- java.util > java.time
- Joda-Time 기반
- 멀티쓰레드 세잎

# 라이브러리
- random : 시드 설정 필요(통계에서 유용하게 사용) / 미 지정시 현재 시각 / 보안으로 인해 예제에서만 사용
- 빌더와 버퍼는 쓰레딩 차이, 기본 capacity 존재


# 게터 세터
- 코틀린은 기본 코드화

# 익명 클래스
- 람다 이전 안드로이드 개발에서 주로 사용 (일급객체 x의 한계)

@ 7

# Object
- @IntrinsicCandidate : 붙으면 JVM이 효율적으로 최적화
- native : 성능이 더 좋은 C, C++ 등 다른 언어로 작성된 코드를 호출
- toString : println시 기본적으로 이 메소드 사용
- equals :  reference 비교는 ==과 같지만 string에서 ==과 다른건 기본적으로 메소드 오버라이드 되있어서임
- HashCode : string의 경우 문자열 값이 같으면 같도록 오버라이드 = 해시값이 같아도 객체가 무조건 같진 않다
- clone : 복사 유형 구분 및 Cloneable 인터페이스 구현 권장, 깊은 복사는 직접 오버라이드해서 사용(참조타입 필드들의 경우 직접해야하므로)


# Wrapper class
- 자바는 primitive를 사용하기에 순수 객체지향 언어는 아니게됨(큰 의미 없음)
- 공통부모 Number

# 제네릭!
- 객체 생성시 <>를 붙여 제네릭 체크(없으면 컴파일러 식별 x)
- 제네릭 메소드와 제네릭 클래스는 제네릭을 사용하는 것만 비슷함
- 제네릭 메소드의 T는 지역 변수, 클래스의 T는 인스턴스 변수처럼 쓰이기에 클래스는 static 사용 불가
- 생성자 선언시 객체 타입과 달리 제네릭끼리는 상속 사용 불가(제네릭 클래스 지정시 args에 따라 객체 성질이 변하므로)
> 이것을 보완하기 위해 와일드카드 ? 도입(상속과 와일드카드 부분 다시 학습)



@ 8

# list
- <integer> remove시 오버로딩을 위해 형변환 조심
- 배열 변환시 object가 아닌 형변환을 위해선 변환시에 함수 지정 필요(명시적 형변환 불가)
- 스택 큐 구현시 LinkedList보다 더 ArrayDeque가 성능이 좋음
- Arrays 사용 실수 조심(prac1 참조)

# set
- hash를 정렬을 목적으로 사용하지 말 것(일정 개수 이하에선 로직상 정렬된 것처럼 보임)
- 객체로 treeset 사용시 당연히 comparator가 추가되어야 함(컴파일 상으론 돌아가긴 함)

# comparable
- 컬렉션에선 정렬에 comparator
- comparable 기본 적용

# iterator
- 이터레이터 사용시 부분 순회 코드 쉽게 구현 가능
- foreach 사용시 이터레이터나 필터 사용(foreach에선 사용 전체 객체가 변경될 수 있는 remove 사용 금지[for 등 지역변수 사용의 경우는 가능])

! 자바엔 call by value만 존재
(자바에서 call by reference가 있다고 배우는 경우 보통 reference value[쉽게 말해 포인터]타입과 용어가 혼동)
- C의 경우 포인터를 직접 개발자가 다루어 메모리 주소에 접근이 가능함
- 자바의 경우 포인터를 최대한 숨겨 메모리 주소를 직접 제어하지 않고 단지 복사하는 것이 값이냐 주소냐만 결정

@ 9

# 람다
- 람다식은 내부적으로 컴파일시 익명 객체화
- comparator의 경우 8 이전에 생성되어 함수형 인터페이스지만 추상 메소드가 둘
- 결국 자바는 클래스 정적 언어이기에 람다를 도입하기 위해 익명 클래스를 사용하는 것(그렇기에 클래스당 메소드 일대일 대응)
# 메서드 참조
- 블 켜는 스위치를 누르는 사람 = 불 켜는 사람
- compareTo와 같은 참조는 복습시마다 눈에 익혀둘 것
- 결국 메소드 참조는 개발자가 자바에서 함수를 인자로 사용할 때 가시성을 위해 있는 것이라 이해하면 편함

# 스트림
- 스트림 사용시 생길 수 있는 성능 저하, 자원 누수, 최적화 문제는 후에 다시 학습
- IntStream 등 원시값 전용 스트림

- 스트림을 디버그하면 인스턴스는 스트림 내부 구현에 따라 파이프라인에 속하게 되고 $Head 처럼 지점별 객체 식별자를 가지게 됨


@ 10

# 예외처리
- error는 보통 시스템 레벨 문제 exception은 대비 가능
- 의도적인 예외 래핑으로 추상화 수준을 높이는 대신 디버깅이 어려워짐

# try catch
- default처럼 catch도 여러개 가능 & 부분 -> 전체
- finally는 return 이후에도 반드시 실행
# throws(메소드<>호출부)
- 떠 넘겨도 호출하는 쪽에선 결국 처리해줘야함(하지만 호출하는 쪽에 throws는 권장되지 않음)
- 되던지기 가능(이 경우 메소드가 예외를 처리하고 넘기기에 가능하며 일반적으론 반드시 예외를 명시적으로 던져야 함)
- chained exception의 경우 initCause로 chain
# try with resources(java 7~)
- finally 대신 사용(try catch에 이어 finally까지 사용시 가독성이 떨어지고 실수의 여지도 있음)
- 자동으로 자원을 닫아주는 만큼 자원을 닫을 수 있는 Closable을 구현하여 사용되고 autoClosable을 구현한 객체만 사용 가능
# Optional
- 매번 NPE에 try catch사용이 번거로워 등장
! 예외 처리는 추가 학습 필요(캐치와 쓰로우가 다른 예외 등)

@ 11

# 쓰레드
- sync1 예제를 통해 일반적인 동기화 과정 설명
- 자바에선 기본적으로 모든 쓰레드들의 시작점은 main 메서드며 코드에 따라 작업의 방향성이 결정됨
- 스프링 역시 JVM 상에서 동작하며 쓰레드 작업의 경우 이 메커니즘을 따름

- 스프링 부트 사용시 일반적으론 보통 쓰레드 작업은 컨테이너에 일임하므로 코드로 쓰레드를 거의 다루진 않음
- run은 메인쓰레드에서 같이 돌리므로 동시 작업은 start
- 코드 상에선 쓰레드의 실행 순서를 강제하는 건 비추천(쓰레드 상 priority를 설정하거나 yield 사용시 jvm에게 힌트를 줄 뿐 os가 무시하면 의미가 없어짐)
- sleep의 경우 인스턴스가 아닌 클래스 상에서 진행할 것 *11.1
- stop은 강제기에 위험이 많아(리소스 누수, 데이터 오염) deprecated > interrupt 사용

# 데몬 쓰레드
- setDaemon을 통해 쓰레드간 종속 관계를 지어줄 수 있음(단순히 쓰레드 안에 생성하는 것으론 안됨)

# 동기화
- 동기화 관련 예제 코드 및 트랜잭션 관련 설명시에도 11.4 참고
- synchronized의 경우 메소드 제어자와 블럭 제어자 둘 중 현 상황에 맞게 선택
- 캐싱 중 메모리 미갱신에 의한 오류 방지를 위해 1. volatile 연산자 사용 2. 단순 원시 변수를 동기화 클래스 메소드로 교체

- 스레드간 동기화시 wait notify를 사용하는 것과 비슷하게 sleep을 사용해서 구현할 수 있긴하지만 비추천
- wait notify 등을 이용한 쓰레드 통신시 반드시 공유 모니터 객체 필요
- notify는 잠든 쓰레드들 중 하나를 깨워 실행가능한 상태로 만드는 것으로 wait보다 먼저 실행하더라도 에러 발생 x

- 만약 하나의 공유자원을 사용한다면 서로 다른 sync 메소드 사이도 동기화가 이루어져야 함

# 쓰레드 풀
- 스프링 컨테이너에서 관리하는 쓰레드풀 역시 다소 차이가 있는 부분이 있지만 대체로 자바에서 다루듯이 코드를 사용함
- 스프링 풀에선 쓰레드가 자리(작업대) Runnable(작업자체)이 대기열로 이해하면 편함
- Callable = Runnable + return, exception > 보통 Future에 많이 쓰임

# Future
- Future의 경우 비동기 처리를 하지만 Callable로 값을 받아와 동기적인 작업에 합류
- Future 사용시 get 사용시 get 이후 코드 중 메인쓰레드 작업 부분에 블로킹이 발생
- CompletableFuture(자바8 도입)는 보통 코드 상 비동기 연산이 길어져 구간별 수정이 필요해져 도입(추가 학습)

# 병렬 스트림
- 병렬 스트림의 경우 변수/환경별로 다 달라 경향은 존재하지만 실제 테스트를 해보고 사용 여부 선택(또한 스트림 중간에 방식 전환도 가능)

# Thread safe
- Ex01 : unsafe한 경우의 예제
- concurrentHashMap의 경우 key별 구획을 지정하고 작업(성능도 더 좋을 때 많음)
- Atomic 클래스는 필드를 쓰레드 세잎하게
- AtomicReference의 경우 감싸주는 참조값은 atomic이지만 인스턴스 자체는 아님

@ 12

# io
- 쓰레드 세잎 x, os간 호환시 문제(경로 처리) > nio로 대체(현재는 거의 안씀)

# nio
- 경로를 문자열 대신 인스턴스로 취급
- 인코딩시 주의
- copyWithFilesClass같은 경우 내부적으로 io버퍼스트림 사용(예외처리, 가독성 면에서 실무에서 사용)
- stringWriter 역시 내부적으로 스트링빌더 사용, 따라서 스트링을 빌더로 메모리 성능을 올리듯 입출력시 writer를 사용하여 메모리 최적화
- Ex04를 보듯 기본적으로 sout의 default printPath는 콘솔(jvm 환경마다 다소 상이)

# 직렬화
- 버전 주의
- List처럼 이미 직렬화가 구현된 클래스도 존재

# 소켓
- 소켓 통신 사용시 프로토콜별 장단점 기억
- 멀티 쓰레드에서 쓰레드 경쟁으로 인한 동기화 문제나 통신 오버헤드, 보안 문제를 고려해야 함
- 소켓 통신은 비교적 저수준(transport)의 프로토콜 사용 > TCP는 Socket이나 ServerSocket UDP는 Datagram
- 웹 소켓은 Http 기반(application)으로 이름만 비슷할 뿐 사용 계층 자체가 다름

@ 13

# 리플렉션
- 어떤 클래스가 들어오더라도 대처해야하는 상황에서 사용
- 클래스로더에 의해 jvm 메모리에 저장된 정보를 가져오므로 런타임에 이뤄지는 API라고 하는것
- 주로 개발환경을 제작하는데 쓰이고 jackson, ORM(hibernate)이나 DI도 내부적으로 리플렉션을 이용
- 컴파일러 최적화를 전혀 받지 못해 성능이 느리며 클래스의 모든 정보가 드러나니 추상화가 파괴되고 보안에 취약점이 발생

# 어노테이션
- @Retention 1. source(컴파일 이전) > override 등 2. class(런타임 이전) > lombok 등 3. runtime > reflection 접근
- 어노테이션은 리플렉션을 이용하고 스프링부트는 어노테이션 기반이므로 사용시 고려할 사항 주의
- 메타 어노테이션 남용시 성능 하락 주의

# 클래스 로더
- HDD에서 메모리로 클래스 파일을 로드하는 건 클래스 로더(아래 세가지 단계)
- 클래스로드 3계층 1 부트스트랩 클래스로더(기본/핵심 라이브러리) 2 확장/플랫폼 클래스로더(jdbc, swing 등) 3 시스템/앱 클래스로더(사용자 코딩/hibernate, junit 등 추가 라이브러리)
- 링크 > 검증 준비 연결
- 초기화 > static 실행(예제 참고)

- 동적 로딩이므로 결국 리플렉션과 비슷

# 자바독
- 인텔리제이 통합 기능 숙지

@ 14

# 소스패스 클래스패스
-




