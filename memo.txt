@클래스와 변수명에 관례 문자열 쓰지 말 것

@자바는 클래스 내부에서 변수 초기화나 메소드 호출이 메소드나 초기화 블록 안에서 이루어져야 함
> 명백한 실행 순서(*), 예외 처리, 유지보수성, 객체지향 면에서 생긴 규칙임을 기억
* 클래스 내부 로직에 메소드 호출을 만약 허용할 경우 인스턴스 변수 초기화시 문제 발생

@코틀린 학습 병행(메모장 참고)

@디버그는 브레이크포인트(디버그시점, 보통 메인메소드 끝) 걸고
브레이크 포인트 여러개 후 디버깅에서 순서대로 볼 수 있음

@디버그 스텝인투(메소드에 브레이크 걸어도 비슷한 효과)

#자료형과 연산
- 삼항 연산자 실습
- 이스케이프 실습
- 스트링 상수 풀과 스트링빌더 추가 학습
- final은 상수라기 보단 일회성 변수로 보는게 나음, 상수 대문자

#정수
- 바이트 쇼트 연산시 인트로 취급
- 초기화 이후의 오버플로우는 컴파일러가 관여x > 런타임에러
- 리터럴은 ++ 사용 불가
- 자료형이 달라도 값이 같다면 동일

#실수
- 1 + 8(exponent) + 23(첫 1포함 앞 전부 제거)
- decimal 라이브러리

#문자
- 문자와 문자열은 연산 방식 다름
- 리터럴과 정수 연산의 형변환 차이
- 공백은 문자 x 문자열 o(str자체가 공백에서 시작)

#불리안
- 애초에 정보 취급시 단위가 비트가 아닌 바이트
- pri && > ||
- 단축평가시 후위의 부수 효과가 적용되지 않음

#문자열
* 리터럴 생성시에만 스트링 상수 풀을 이용하여 중복값 동일 참조 > 따라서 최대한 string은 리터럴 사용
- 인스턴스 생성시 기존 참조처럼 작동
- + 복합대입연산(+=)은 가능
- Boolean.parseBoolean은 "true" 제외 모두 false

#문자열 메소드
- \t \n 등도 일부 메소드 공백 취급
- concat : 문자열만, 필요시만 새 인스턴스(+는 늘 생성), null 체크(+는 무시), 그러나 성능은 +가 좋음(다중 연산시 매번 값 생성)
- replaceAll/First의 regrex는 정규표현식

#포매팅
- 13버전부터는 변수에 .formatted 가능/이전까지는 String 메서드
- printf
- 리눅스는 \n 윈도우는 \r\n : 옛 타자기시절 개행시 왼쪽으로 넘기는 전통
> 따라서 %n으로 OS별 줄바꿈 통일
- 기본적으로 %f는 6자리까지

#null
- 초기화되지 않은 객체 > 컴파일, null > 런타임

#array
- 초기화시 숫자는 0 bool은 false char은 아스키코드 0 string은 null

#타입추론
- var 선언시 반드시 초기화 필요/local var만 가능

#if
- 인텔리제이 단축어 foreach

#switch
- break 없으면 case 틀려도 내부 출력

#for
- 최대한 변수를 줄일수록 안전한 for loop(lambda도 마찬가지)

#메소드
- 함수와의 차이는 클래스 의존성 > 역사는 과거 언어인 simula
- 메소드 선언시 param, 메소드 사용시 argum
- ...(varargs)는 기본적으로 primitive를 배열로 묶지만 배열이 들어와도 작동
- varargs는 가장 마지막 param으로 사용, 중복 사용 불가

#재귀
- 재귀함수 자체도 별로지만 자바에선 보안 등의 이슈로 꼬리 재귀 최적화가 불가
- 꼬리 재귀 사용 선택 고려

#클래스
- C의 구조체와 거의 유사하며 C++의 경우 구조체와 클래스간 상속도 제한적으로 가능
- public이 아니면 파일명 클래스명 일치할 필요 X(컴파일 후 .class 파일을 인터프리팅할 때 공용 클래스 식별)
* 클래스 로더가 클래스를 찾을 때 특정한 규칙을 따르는데, 이 때 메인 메소드가 그 시작점이 되므로 static을 쓰듯이 Class.main처럼 jvm이
사용하기 쉽도록 관례상 적용
- this 생성될 인스턴스, #1 매개변수 구분을 위해서도 사용(클래스, 인스턴스 멤버)
- 생성자는 컴파일러가 자동 생성

#인스턴스
- 객체와 인스턴스는 자바에선 거의 동등하게 사용되지만 개념적이거나 다른 언어에선 객체가 더 포괄적이고 인스턴스가 더 구체적인 표현
- 클래스의 인스턴스화는 다음 순서를 가짐
1 메모리 할당 2 인스턴스 변수 초기화(int라면 0으로) 3 생성자 호출


#static
- 인스턴스에서도 클래스 변수를 사용할 수는 있음.(비권장, IDE 자동완성 x)

#접근제어
- modifier로 제한자 병기도 자주 사용

#상속
- private같은 접근제어도 상속은 되지만 외부 사용은 불가
- 자식의 생성자는 무조건 super 시작(즉, 부모 인스턴스 반드시 생성)
- 부모 생성자 선언 x > 자식도 x 가능 (부모 선언시 자식도 반드시 선언)

#인터페이스
- 하위호환성을 위한 default 메소드 추가로 유연성을 확보하고 라이브러리 추가가 더 유연해짐(호환을 유지하며
새로운 기능 추가)

#패키지
- out 빌드 파일 직접 실행해보기

#메인메소드
- args : 인수보다 큰 의미는 없음

#enum
- 코드 가독성 및 실수 방지를 위해 도입(이전엔 final > interface 상수 > 객체 상수를 겪음)
- 필드, 메소드, 생성자 사용 가능
- reference type이기에 힙에 따로 저장
- 메모리를 따로 먹기에 고려되는 성능 문제의 경우도 미미함

#레코드
- 16부터 도입, class와 enum의 중간(근본적으론 class)
- js의 jason이나 c의 구조체와 유사
- 인터페이스 필드처럼 기본적으로 final + private며 생성자, getter가 기본 생성
- inner class처럼 클래스 내부 사용 가능
- class 필드는 가질 수 있음, 인터페이스 구현 가능

#time
- java.util > java.time
- Joda-Time 기반
- 멀티쓰레드 세잎

#라이브러리
- random : 시드 설정 필요(통계에서 유용하게 사용) / 미 지정시 현재 시각 / 보안으로 인해 예제에서만 사용
- 빌더와 버퍼는 쓰레딩 차이, 기본 capacity 존재


#게터 세터
- 코틀린은 기본 코드화

#익명 클래스
- 람다 이전 안드로이드 개발에서 주로 사용 (일급객체 x의 한계)

@ 7

# Object
- @IntrinsicCandidate : 붙으면 JVM이 효율적으로 최적화
- native : 성능이 더 좋은 C, C++ 등 다른 언어로 작성된 코드를 호출
- toString : println시 기본적으로 이 메소드 사용
- equals :  reference 비교는 ==과 같지만 string에서 ==과 다른건 기본적으로 메소드 오버라이드 되있어서임
- HashCode : string의 경우 문자열 값이 같으면 같도록 오버라이드 = 해시값이 같아도 객체가 무조건 같진 않다
- clone : 복사 유형 구분 및 Cloneable 인터페이스 구현 권장, 깊은 복사는 직접 오버라이드해서 사용(참조타입 필드들의 경우 직접해야하므로)


# Wrapper class
- 자바는 primitive를 사용하기에 순수 객체지향 언어는 아니게됨(큰 의미 없음)
- 공통부모 Number

# 제네릭!
- 객체 생성시 <>를 붙여 제네릭 체크(없으면 컴파일러 식별 x)
- 제네릭 메소드와 제네릭 클래스는 제네릭을 사용하는 것만 비슷함
- 제네릭 메소드의 T는 지역 변수, 클래스의 T는 인스턴스 변수처럼 쓰이기에 클래스는 static 사용 불가
- 생성자 선언시 객체 타입과 달리 제네릭끼리는 상속 사용 불가(제네릭 클래스 지정시 args에 따라 객체 성질이 변하므로)
> 이것을 보완하기 위해 와일드카드 ? 도입



@ 8

# list set map
# comparable
- 컬렉션에선 정렬에 comparator
- comparable 기본 적용
# iterator
- foreach 사용시 주의 / 엔트리의 컬렉션 이터레이트 가능

! 자바엔 call by value만 존재
(자바에서 call by reference가 있다고 배우는 경우 보통 reference value[쉽게 말해 포인터]타입과 용어가 혼동)
- C의 경우 포인터를 직접 개발자가 다루어 메모리 주소에 접근이 가능함
- 자바의 경우 포인터를 최대한 숨겨 메모리 주소를 직접 제어하지 않고 단지 복사하는 것이 값이냐 주소냐만 결정

@ 10

# 예외처리
- error는 보통 시스템 레벨 문제 exception은 대비 가능
# try catch
- default처럼 catch도 여러개 가능 & 부분 -> 전체
- finally는 return 이후에도 반드시 실행
# throws(메소드<>호출부)
- 떠 넘겨도 호출하는 쪽에선 결국 처리해줘야함(하지만 호출하는 쪽에 throws는 권장되지 않음)
- 되던지기 가능(이 경우 메소드가 예외를 처리하고 넘기기에 가능하며 일반적으론 반드시 예외를 명시적으로 던져야 함)
- chained exception의 경우 initCause로 chain
# try with resources(java 7~)
- finally 대신 사용(try catch에 이어 finally까지 사용시 가독성이 떨어지고 실수의 여지도 있음)
# Optional
- 매번 NPE에 try catch사용이 번거로워 등장
! 예외 처리 마지막 강은 스트림 학습 이후 다시 볼 것

@ 11

# 쓰레드
- 스프링 부트 사용시 일반적으론 보통 쓰레드 작업은 컨테이너에 일임하므로 코드로 쓰레드를 거의 다루진 않음
- run은 메인쓰레드에서 같이 돌리므로 동시 작업은 start
- 코드 상에선 쓰레드의 실행 순서를 강제하는 건 비추천(쓰레드 상 priority를 설정하거나 yield 사용시 jvm에게 힌트를 줄 뿐 os가 무시하면 의미가 없어짐)
- sleep의 경우 인스턴스가 아닌 클래스 상에서 진행할 것 *11.1
- stop은 강제기에 위험이 많아(리소스 누수, 데이터 오염) deprecated > interrupt 사용

