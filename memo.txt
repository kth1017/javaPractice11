@ 디버그는 브레이크포인트(디버그시점, 보통 메인메소드 끝) 걸고
브레이크 포인트 여러개 후 디버깅에서 순서대로 볼 수 있음

#자료형과 연산
- 삼항 연산자 실습
- 이스케이프 실습
- 스트링 상수 풀과 스트링빌더 추가 학습
- final은 상수라기 보단 일회성 변수로 보는게 나음, 상수 대문자

#정수
- 바이트 쇼트 연산시 인트로 취급
- 초기화 이후의 오버플로우는 컴파일러가 관여x > 런타임에러
- 리터럴은 ++ 사용 불가
- 자료형이 달라도 값이 같다면 동일

#실수
- 1 + 8(exponent) + 23(첫 1포함 앞 전부 제거)
- decimal 라이브러리

#문자
- 문자와 문자열은 연산 방식 다름
- 리터럴과 정수 연산의 형변환 차이
- 공백은 문자 x 문자열 o(str자체가 공백에서 시작)

#불리안
- 애초에 정보 취급시 단위가 비트가 아닌 바이트
- pri && > ||
- 단축평가시 후위의 부수 효과가 적용되지 않음

#문자열
* 리터럴 생성시에만 스트링 상수 풀을 이용하여 중복값 동일 참조 > 따라서 최대한 string은 리터럴 사용
- 인스턴스 생성시 기존 참조처럼 작동
- + 복합대입연산(+=)은 가능
- Boolean.parseBoolean은 "true" 제외 모두 false

#문자열 메소드
- \t \n 등도 일부 메소드 공백 취급
- concat : 문자열만, 필요시만 새 인스턴스(+는 늘 생성), null 체크(+는 무시), 그러나 성능은 +가 좋음(다중 연산시 매번 값 생성)
- replaceAll/First의 regrex는 정규표현식

#포매팅
- 13버전부터는 변수에 .formatted 가능/이전까지는 String 메서드
- printf
- 리눅스는 \n 윈도우는 \r\n : 옛 타자기시절 개행시 왼쪽으로 넘기는 전통
> 따라서 %n으로 OS별 줄바꿈 통일
- 기본적으로 %f는 6자리까지

#null
- 초기화되지 않은 객체 > 컴파일, null > 런타임

#array
- 초기화시 숫자는 0 bool은 false char은 아스키코드 0 string은 null

#타입추론
- var 선언시 반드시 초기화 필요/local var만 가능

#if
- 인텔리제이 단축어 foreach

#switch
- break 없으면 case 틀려도 내부 출력

#for
- 최대한 변수를 줄일수록 안전한 for loop(lambda도 마찬가지)

